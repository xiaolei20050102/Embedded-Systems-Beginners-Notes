$STM32$  学习笔记杂项

## 

## 关于在$Keil5$ 里面 新建$STM32$工程

------

1. 打开Keil5在工具栏里面选择Project -> New μVison Project 新建一个工程。

![image-20250912202018140](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912202018140.png)

2.根据自己的芯片选择即可

![image-20250912202348846](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912202348846.png)

3.工程文件夹下新建一个文件夹Strat里面存放，**基本启动文件**、**外设寄存器描述文件**、**配置时钟的文件**、**内核寄存器描述文件**。

![image-20250912204358054](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912204358054.png)

4.工程文件夹下新建一个文件夹Library里面存放，**标准外设驱动文件**（使用库函数编程必备）。

![image-20250912205154395](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912205154395.png)

5.工程目录下新建User作为用户文件夹，里面存放**库配置文件**、**中断服务程序源文件**、**中断服务程序头文件**。

![image-20250912205908454](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912205908454.png)

6.回到keil里面添加Strat、Library、User组，并且添加相关文件。

![image-20250912210707235](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912210707235.png)

7.在Option for Target ‘Target1’（小魔术棒） 中 C/C++  下include Path中添加上述组文件夹的路径。

![image-20250912211052635](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912211052635.png)

![image-20250912211222519](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912211222519.png)

8.在User组下新建main.c文件，写入测试代码，同时在Option for Target ‘Target1’（小魔术棒） 中 C/C++ Define 栏中添加USE_STDPERIPH_DRIVER 宏定义

![image-20250912211813583](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912211813583.png)

9.点击build target files。如果0 error 0 waring 就ok 了。

![image-20250912212020052](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250912212020052.png)







## 关于上拉输入和下拉输入

------

- 

    **默认状态（悬空）**：当输入引脚**什么都不接**时，它的状态完全由您软件配置的**内部上拉或下拉电阻**决定。就像一辆停在坡上的车，您拉了手刹（上拉）它就不会溜车。

- 

    **强外部驱动**：当您用一个**稳定的外部信号源**（如直接接 `GND`或 `VCC`）驱动该引脚时，这个外部信号的驱动能力远强于内部微弱的上拉/下拉电阻。因此，**外部信号会覆盖内部电阻的效果**，引脚的电平将由外部信号决定。就像您用力推那辆停了手刹的车，它依然会被推动。

**简单来说：软件配置的上拉/下拉只决定了“没人说话时听谁的”；而一旦外部有个“大嗓门”明确发声，大家就都会听它的。**

这个设计保证了电路的稳定性和灵活性，是所有单片机输入设计的基础。





## 关于推挽输出和开漏输出

------

- 推挽输出，输出1（高电平）——> 输出高电平，输出0（低电平）——> 输出低电平。
- 开漏输出，输出1（高电平）——> 高电平断开（成高阻）,输出0（低电平）——> 输出低电平。





## 关于AO和DO

------

**AO (Analog Output) - 模拟信号输出**

**DO (Digital Output) - 数字信号输出**

区别：

|        性        |           **AO (模拟输出)**            |           **DO (数字输出)**           |
| :--------------: | :------------------------------------: | :-----------------------------------: |
|   **信号性质**   |              连续模拟信号              |             离散数字信号              |
|   **输出范围**   | 电压值 (0V ~ VCC) → 量化值 (如 0-1023) | 二值：**高电平 (1)** / **低电平 (0)** |
|   **核心电路**   |              **分压电路**              |      **电压比较器** + 可调电位器      |
| **微控制器接口** |         **ADC** (模拟输入引脚)         |   **GPIO** (通用数字输入/输出引脚)    |
|    **信息量**    |          丰富 (包含强度大小)           |          单一 (仅有状态判断)          |







## 关于NVIC

------

**全名：nested vectored interrupt controller 	嵌套向量中断控制器**

**本质**：ARM Cortex-M内核内部的一个**硬件单元**，用于**集中管理**所有中断请求。

**目标**：实现中断的**快速响应**和**高效管理**，是微控制器实时性的关键保障

在配置NVIC时，你需要把“优先级”这个值分成两个部分来使用：

1.**抢占优先级 (Preemption Priority)**

- **决定权**：**“谁能打断谁”**。
- **规则**：不同抢占优先级的中断之间，**高者（数值小）可以打断低者（数值大）**。这是实现中断嵌套的根本。

2.**子优先级/响应优先级 (Subpriority / Response Priority)**

- **决定权**：**“同时到来时谁先执行”**。
- **规则**：**只有当两个中断的抢占优先级完全相同时**，才会比较子优先级。子优先级高的（数值小）会先被执行。
- **关键**：**子优先级不同的中断不能互相嵌套**。一个正在执行的低子优先级中断，不会被一个高子优先级但抢占优先级相同的中断所打断。

NVIC的中断优先级由优先级寄存器的**4位**（取值范围0~15）来决定。这4位可以通过不同的分组方式，被切分为**抢占优先级（Preemption Priority）** 和**响应优先级（Subpriority，也称子优先级）** 两部分。

3.两种优先级的区别：

- **抢占优先级**：决定中断是否能够**嵌套**。高抢占优先级的中断可以打断低抢占优先级的中断。
- **响应优先级**：当**多个中断同时发生且抢占优先级相同时**，用来决定它们的执行顺序。高响应优先级的中断会先被处理。**注意：响应优先级不同的中断不能互相嵌套。**

4. 优先级分组规则：

展示5种分组方式：

| 分组方式  | 抢占优先级位数 | (取值个数) | 响应优先级位数 | (取值个数) |
| --------- | -------------- | ---------- | -------------- | ---------- |
| **分组0** | 0位            | (1种)      | 4位            | (16种)     |
| **分组1** | 1位            | (2种)      | 3位            | (8种)      |
| **分组2** | 2位            | (4种)      | 2位            | (4种)      |
| **分组3** | 3位            | (8种)      | 1位            | (2种)      |
| **分组4** | 4位            | (16种)     | 0位            | (1种)      |

**分组的选择决定了系统中最多能有多少种不同的嵌套层次（抢占优先级数量），以及同一嵌套层次下有多少种排队顺序（响应优先级数量）。**

5.如何选择分组？

这取决于你的应用程序需要多少级中断嵌套。

- 如果你的系统需要很多级中断嵌套（如一个复杂的中断系统），应选择**分组4**（16级抢占优先级，0级响应优先级）。
- 如果你的系统中断源很多，但需要嵌套的层级不多，但需要精细的排队顺序，可以选择**分组0**（1级抢占优先级，16级响应优先级）。
- 绝大多数STM32例程和库（如HAL库）默认使用**分组4**，即所有位都用于抢占优先级，这样配置最简单直观。

6.总结规则：

- **抢占优先级**不同的中断：**高者可打断低者**（嵌套）。
- **抢占优先级**相同的中断：**无法互相嵌套**，比较响应优先级，**高者先执行**。
- **抢占优先级和响应优先级**都完全相同的 interrupt：比较它们的**自然中断号**，中断号小的优先。







## 关于EXTI

------

**External Interrupt (外部中断) **

**一、功能**

监测指定GPIO引脚的电平变化，一旦检测到**边沿跳变**，立即向NVIC申请中断，迫使CPU中断主程序，转去执行中断服务程序。

**二、核心特性**

1. **触发方式**（可配置）：
    - **上升沿**（低变高）
    - **下降沿**（高变低）
    - **双边沿**（任意变化）
    - **软件触发**（通过程序代码手动产生中断）
2. **响应模式**：
    - **中断响应**：通向CPU，执行中断函数。**最常用**。
    - **事件响应**：通向其他外设，不经过CPU，用于快速触发硬件动作（如触发ADC启动）。
3. **资源分配**：
    - **16条外部线**（0-15）：每条线可映射到**任意GPIO端口的同一编号引脚**（如EXTI0可连PA0、PB0等，但**不能同时**连接）。
    - **额外内部线**：用于连接PVD、RTC闹钟、USB唤醒等内部事件源。

**三、工作流程**

```
GPIO电平变化`-> `EXTI检测并捕获`-> `EXTI向NVIC发请求`-> `NVIC裁决优先级`-> `CPU执行中断函数
```

**总结**：EXTI是STM32响应**外部引脚信号变化**最直接、高效的机制，是实现按键、传感器等外部异步信号实时处理的关键。









## 关于AFIO

------

STM32的**AFIO (Alternate Function I/O，复用功能I/O)**。

**一、 角色定位**

AFIO是STM32芯片内部的一个**功能管理单元**，是GPIO模块的一部分。它本质上是芯片内部的**一个“多功能开关”或“路由调度员”**。

**二、 核心功能**

AFIO主要负责管理GPIO引脚的第二功能，具体包含三大核心职责：

1. **引脚重映射 (Remap) - 最主要功能**
    - **是什么**：允许将芯片**内部外设的功能**（如USART1、SPI1、TIM2等）从其**默认引脚**分配到**备用的另一组引脚**上。
    - **为什么**：
        - **解决冲突**：避免默认引脚被占用导致外设无法使用。
        - **优化PCB布局**：为电路板布线提供更大灵活性。
    - **限制**：重映射的目标引脚是**固定的**，需查阅芯片数据手册的 **“Alternate function mapping”** 表格。
2. **配置外部中断线 (EXTI Configuration)**
    - **是什么**：决定具体的**外部中断线（EXTI0~EXTI15）** 与哪个**GPIO端口**（Port A, B, C...）连接。
    - **如何工作**：通过配置 `AFIO_EXTICR`寄存器，选择某个EXTI线的中断源。例如，选择 `EXTI0`是由 `PA0`、`PB0`还是 `PC0`来触发。
    - **注意**：EXTI线只有16条，这是一个硬件限制。
3. **调试端口配置 (Debug Port Remap)**
    - **是什么**：可以禁用或部分禁用JTAG/SWD调试接口（如JTAG-DP）。
    - **为什么**：释放调试接口占用的GPIO引脚（如PA15, PB3, PB4），将它们作为普通I/O引脚使用。

**三、 重要注意事项**

- **时钟使能**：使用AFIO的任何功能前，**必须首先开启AFIO的时钟**（`__HAL_RCC_AFIO_CLK_ENABLE();`），否则配置无效。
- **硬件资源**：AFIO管理的重映射和EXTI资源是有限的（如仅16条EXTI线），需要在项目初期规划好引脚分配。

**四、 工作流程类比**

将芯片内部想象成一个**大型火车站**：

- **外设（USART, SPI）**： like 火车。
- **GPIO引脚**： like 站台。
- **AFIO**： like **站内调度系统**。
    - 默认情况下，每列火车（外设）有固定的站台（默认引脚）。
    - AFIO这个调度系统可以根据需要，**动态地更改火车停靠的站台**（重映射），或者**决定哪条铁轨（EXTI线）连接哪个站台的信号灯**（EXTI配置）。

------

**总结表**

| 特性         | AFIO (复用功能I/O)                                           |
| ------------ | ------------------------------------------------------------ |
| **核心作用** | **GPIO引脚功能的“调度员”**，管理引脚的第二功能。             |
| **三大功能** | 1. **外设引脚重映射** (最主要)  2. **EXTI中断源选择**  3. **调试端口配置** |
| **使用前提** | **必须使能AFIO时钟** (`__HAL_RCC_AFIO_CLK_ENABLE()`)         |
| **重要性**   | 是进行**PCB硬件设计和软件引脚分配**时必须考虑的核心模块，提供了设计的灵活性。 |

**总而言之，AFIO是STM32引脚应用中最灵活、最强大的部分之一，它让你能够摆脱默认引脚的限制，自由地规划和优化你的硬件设计。**







## 关于EXITI配置流程

GPIO 设置输入 → AFIO 选择 EXTI 线路 → EXTI 设置触发条件并开中断 → NVIC 配置优先级并开中断 。

![image-20250918145353400](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20250918145353400.png)







## 关于中断小细节

------

对于**已使能的中断**（`EXTI_IMR=1`），如果不清除标志位（`EXTI_PR`），NVIC会**持续向CPU提交中断请求**，导致CPU反复执行中断服务函数（ISR），形成死循环。





## 关于**`EXTI_GetFlagStatus`** 和 **`EXTI_GetITStatus`**区别

------

**核心区别总结**

| 特性                   | `EXTI_GetFlagStatus`                                         | `EXTI_GetITStatus`(图中使用的函数)                           |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **检查对象**           | **仅**检查中断标志位 (`EXTI_PR`寄存器)                       | **同时**检查中断标志位 (`EXTI_PR`) **和** 中断使能掩码 (`EXTI_IMR`寄存器) |
| **返回值含义**         | `SET`: 指定中断线的标志位被置位 `RESET`: 标志位未置位        | `SET`: 中断**已使能** **且** 标志位被置位 `RESET`: 中断未使能 **或** 标志位未置位 |
| **是否受中断使能影响** | **❌ 不受影响** 即使中断未使能，只要硬件事件发生，就能检测到标志位 | **✅ 受影响** 只有在中断使能的前提下，标志位置位才返回 `SET`  |
| **典型应用场景**       | **轮询模式** 在主循环中手动检查事件是否发生                  | **中断服务函数 (ISR)**  在中断内**确认有效的中断源**（如图中代码） |
| **安全等级**           | 低（可能检测到被软件禁用的中断）                             | **高（推荐）** 确保响应的中断是当前已开启的                  |

------

**函数功能详解**

**1. `FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)`**

- **功能**：像一个“**事件记录仪**”，只负责查询**某个事件（如上升沿）是否发生过**。

- **底层操作**：直接读取 `EXTI->PR`寄存器的指定位。

- **示例**：

    ```
    // 在主循环中轮询检查PA0是否有上升沿，即使中断未开启也能检测到
    if(EXTI_GetFlagStatus(EXTI_Line0) == SET) {
        printf("检测到PA0有上升沿事件！\n");
        EXTI_ClearFlag(EXTI_Line0); // 手动清除记录
    }
    ```

**2. `ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)`**

- **功能**：像一个“**中断有效性验证器**”，不仅检查事件是否发生，还检查**这个中断是否被允许上报**。

- **底层操作**：执行 `(EXTI->IMR & EXTI->PR)`操作，即检查中断使能掩码和挂起寄存器的**与操作**。

- **示例**：

    ```
    // 只能在中断服务函数中使用！
    void EXTI0_IRQHandler() {
        // 确保是EXTI0触发且其中断已使能，才进行处理
        if (EXTI_GetITStatus(EXTI_Line0) == SET) {
            // 处理中断
            EXTI_ClearITPendingBit(EXTI_Line0);
        }
    }
    ```







## 配置外部中断的流程

------

好的，根据您提供的代码和上下文，为您总结STM32外部中断（EXTI）的**最精简配置流程**，共4步：

------

### **STM32 EXTI 配置四步曲**

#### **1. 配置GPIO (引脚)**

- 设置为**输入模式**（上拉/下拉/浮空）。
- **开启GPIO时钟**。

```
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
GPIO_Init(GPIOB, &GPIO_InitStructure); // 模式: GPIO_Mode_IPU/IPD/IN_FLOATING
```

#### **2. 配置AFIO (路由)**

- **开启AFIO时钟**（必须！）。
- 将GPIO引脚**映射**到对应的EXTI线。

```
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14); // PB14 -> EXTI14
```

#### **3. 配置EXTI (触发条件)**

- 选择中断线、触发边沿（上升/下降/双边），并**使能**。

```
EXTI_InitStructure.EXTI_Line = EXTI_Line14;
EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿
EXTI_InitStructure.EXTI_LineCmd = ENABLE; // !!!必须使能!!!
EXTI_Init(&EXTI_InitStructure);
```

#### **4. 配置NVIC (CPU开关)**

- 设置优先级，并**使能中断通道**（最易忘记！）。
- **EXTI10-15共用 `EXTI15_10_IRQn`** 通道。

```
NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; // !!!通道名不能错!!!
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; // !!!必须使能!!!
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // 抢占优先级
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // 子优先级
NVIC_Init(&NVIC_InitStructure);
```

------

### **中断函数模板（照抄即可）**

```
// EXTI10-15中断服务函数
void EXTI15_10_IRQHandler(void) {
    if (EXTI_GetITStatus(EXTI_Line14) == SET) { // 检查具体线路
        // 你的处理逻辑
        EXTI_ClearITPendingBit(EXTI_Line14); // !!!必须清除标志位!!!
    }
}
```

------

### **核心口诀**

1. **开时钟**：GPIO和AFIO时钟必须开。
2. **映射引脚**：用 `GPIO_EXTILineConfig`连接引脚和EXTI线。
3. **双使能**：EXTI的 `LineCmd`和 NVIC的 `IRQChannelCmd`都必须 `ENABLE`。
4. **清标志**：在中断函数中**必须**调用 `ClearITPendingBit`。

### **常见坑点**

- **忘了开AFIO时钟** -> 整个EXTI配置无效。
- **忘了开NVIC使能** -> CPU收不到中断请求。
- **用错中断通道**（如把EXTI14写成 `EXTI14_IRQn`）-> 中断函数永不执行。
- **忘了清除标志位** -> 中断只触发一次，然后死循环。

按照这个流程和口诀操作，您的EXTI中断一定能成功配置！







## 关于如何分辨GPIO引脚口配置输入模式

------

根据外设模块有效输入数字信号来看，有效输出高电平就下拉，反之上拉。

